<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <description>
  <title-info>
   <genre>comp_programming</genre>
   <author>
    <first-name>Олег</first-name>
    <last-name>Бройтман</last-name>
   </author>
   <book-title>Python - основные концепции</book-title>
   <annotation>
    <p>Python - объектно-ориентированный язык сверхвысокого уровня. Python, в отличии от Java, не требует исключительно объектной ориентированности, но классы в Python так просто изучить и так удобно использовать, что даже новые и неискушенные пользователи быстро переходят на ОО-подход.</p>
   </annotation>
   <date></date>
   <lang>ru</lang>
  </title-info>
  <document-info>
   <author>
    <first-name>Вадим</first-name>
    <last-name>Кузнецов</last-name>
   </author>
   <program-used>ExportToFB21, FB Editor v2.0</program-used>
   <date value="2007-12-17">17.12.2007</date>
   <id>OOo-ExportToFB21-2007121720569</id>
   <version>1.0</version>
  </document-info>
 </description>
 <body>
  <title>
   <p>Python - основные концепции</p>
   <p><strong>[</strong><a l:href="mailto:alv@newmail.ru" type="note">Олег Бройтман</a><strong>]</strong></p>
  </title>
  <section>
   <p><a l:href="http://www.python.org/" type="note">Python</a> - объектно-ориентированный язык сверхвысокого уровня. Python, в отличии от Java, не требует исключительно объектной ориентированности, но классы в Python так просто изучить и так удобно использовать, что даже новые и неискушенные пользователи быстро переходят на ОО-подход. Python поддерживает множественное наследование, переопределение инфиксных операторов, причем можно переопределить операцию как для левого операнда, так и для правого; в версии 2.1 есть полное переопределение операторов сравнения (механизм rich comparison для объектов, поддерживающих частичное упорядочивание, например, матриц).</p>
   <p>В Python имеются исключения и механизм их перехвата; таким образом программист может построить правильную обработку ошибок и создать надежную программу. Встроенные механизмы интроспекции позволяют опрашивать интерфейсы объектов во время выполнения программы. Например, можно узнать количество и имена параметров функции; эту интроспекцию использует Zope, чтобы подготовить правильный список параметров функции при вызове ее из web.</p>
   <p>Из современных языков Python можно сравнить в первую очередь с Java и Perl. Python выполняет все обещания, которые дала, но не выполнила Java. Python очень хорошо переносим. Он работает на всех платформах, на которых есть Java, и еще на многих. Мало найдется таких платформ, на которые Python не перенесен. Я не говорю про UNIX и Windows, конечно - с точки зрения переносимости куда интереснее такие платформы как Mac, Amiga, Palm, RiscOS, AS/400 и многие другие. Для особых любителей Java есть Jython. Он состоит из двух частей: во-первых, это интерпретатор Pyhon, написанный на Java, а во-вторых это компилятор Python в байт-код Java. В сравнении с Perl - Python как язык ему совершенно равномощен, но избавлен от великого множества неприятностей и неудобств, присущих Perl. Python обладает богатой стандартной библиотекой, плюс великим множеством модулей, доступных в Интернете. Для пользователей Windows есть пакет win32, из которого доступны практически все функции Windows API, DDE, COM.</p>
   <p>Существует Русскоязычная Группа Пользователей Python и Zope. Сайт группы расположен по адресу <a l:href="http://zope.net.ru/" type="note">http://zope.net.ru/</a>. На список рассылки можно подписаться, послав по адресу <a l:href="mailto:majordomo@list.glas.net?body=subscribe+python" type="note">mailto:majordomo@list.glas.net?body=subscribe+python</a> письмо с телом subscribe python.</p>
  </section>
  <section>
   <title>
    <p>Основные структуры управления</p>
   </title>
   <p>Python - вполне обычный, можно сказать, "традиционный" язык программирования. Все привычные конструкции в языке есть - условный оператор if, циклы for и while, функции, классы, модули, пакеты (иерархические совокупности модулей). Нет цикла do-while и оператора case.</p>
   <p>Из менее традиционных операторов - возбуждение исключений raise и их перехват try-except-else и try-finally. Впрочем, исключения начинают занимать свое место и в других современных языках, так что чем-то революционным их назвать нельзя.</p>
   <p>Для многих становится неожиданным, что в Питоне блочная структура обозначается отступами, а не словами begin/end (или скобками). К этому, однако, быстро привыкаешь, и это становится очень удобно.</p>
  </section>
  <section>
   <title>
    <p>Базовые типы данных</p>
   </title>
   <p>Для языка Python создано несколько интерпретаторов. В дальнейшем я буду говорить про основной интерпретатор CPython (интерпретатор, написанный на C).</p>
   <p>В этом интерпретаторе базовые (встроенные) типы данных - целое, длинное целое, вещественное, комплексное числа, строки, списки, кортежи и словари.</p>
   <p>Целое в Питоне соответствует типу long того компилятора C, которым скомпилирован интерпретатор. Длинное целое - это целое число потенциально бесконечной длины; с помощью таких чисел можно производить вычисления неограниченной разрядности; длинные целые эмулируются библиотекой, встроенной в интерпретатор. Вещественное соответствует типу double. Комплексные числа - это пара вещественных, записываемых в инженерной (а не математической) нотации: 21 + 12j.</p>
   <p>Строки - просто последовательности символов. Строки бывают ASCII и Unicode, их можно перекодировать друг в друга. ASCII-строки можно также перекодировать в другую кодировку (например, koi8 &lt;=&gt; win1251)</p>
   <p>Списки в качестве элементов могут содержать любые объекты. Списки неограниченной длины, и в них можно добавлять и удалять элементы, изменяя таким образом их длину. Списки в Питоне одномерные. Для эмуляции многомерных массивов можно использовать списки, элементами которых являются списки. Для эффективной обработки многомерных числовых матриц есть дополнительный модуль расширения <a l:href="http://www.pfdubois.com/numpy/" type="note">Numerical Python</a>.</p>
   <p>Словари (ассоциативные массивы) - это отображения (mapping), сопоставляющие уникальному ключу произвольный объект. Ключом словаря может быть любой неизменяемый объект.</p>
  </section>
  <section>
   <title>
    <p>Изменяемые и неизменяемые объекты; адресная арифметика и ссылки</p>
   </title>
   <p>Объекты в Питоне бывают двух разновидностей - изменяемые и неизменяемые. Списки, например - объекты изменяемые, их содержимое и длину можно менять. Поскольку ключами словарей могут быть только неизменяемые объекты, в Питоне есть специальный тип неизменяемых списков - кортежи. Числа, естественно, объекты неизменяемые. Также неизменяемыми являются строки, в отличии от многих других языков программирования. Хотя классы, написанные программистами, порождают изменяемые объекты, у программиста есть возможность написать класс, экземпляры которого могут быть ключами словаря.</p>
   <p>Адресной арифметики в Питоне нет. Вообще. Поэтому разименовать нулевой указатель просто невозможно. Ссылки (указатели) в Питоне есть, но манипулирование ими осуществляется прозрачно для программиста. В действительности все переменные в Питоне являются ссылками на объекты; поэтому, например, запись <emphasis>a</emphasis> = <emphasis>b</emphasis> означает "в переменную <emphasis>a</emphasis> скопировать ссылку из переменной <emphasis>b</emphasis>". Также списки и словари хранят не объекты, а ссылки на объекты. Присваивание и разыменование ссылок производится автоматически.</p>
   <p>Каждый объект в Питоне хранит счетчик ссылок, и при таком копировании ссылки этот счетчик увеличивается. Счетчик же ссылок того объекта, на который переменная <emphasis>a</emphasis> указывала раньше - уменьшается. Когда счетчик достигает 0, объект считается неиспользуемым, для него вызывается деструктор (если это экземпляр класса с деструктором), и память объекта освобождается.</p>
   <p>Такой механизм называется "синхронной сборкой мусора со счетчиком ссылок". Помимо него, в Питоне есть асинхронный сборщик мусора, достоинство которого в том, что он умеет распознавать циклические ссылки и очищать объекты, на которые нет других ссылок (не из цикла). (Пример циклических ссылок: l=[]; l.append(l))</p>
   <p>Рассмотрим поподробнее питоновские ссылки. Создадим список и присвоим его (на самом деле присвоим ссылку на него) в переменную <emphasis>a</emphasis>: <emphasis>a</emphasis> = [21, 12, "str"]. Теперь присвоим ссылку из <emphasis>a</emphasis> в переменную <emphasis>b</emphasis>: <emphasis>a</emphasis> = <emphasis>b</emphasis>. Изменим список, на который ссылается <emphasis>a</emphasis>, скажем, добавим в него содержимое другого списка: <emphasis>a</emphasis> += [2000]. На какой список ссылается переменная <emphasis>b</emphasis>? На тот же, что и <emphasis>a</emphasis> - на список из 4 элементов. Происходит это потому, что <emphasis>b</emphasis> все еще хранит ссылку на тот же список, что и <emphasis>a</emphasis>. А теперь присвоим в <emphasis>a</emphasis> новый список: <emphasis>a</emphasis> = [12, 21]. Что теперь будет в <emphasis>b</emphasis>? А все тот же список из 4 элементов. Присваивание в <emphasis>a</emphasis> разорвало связь между <emphasis>a</emphasis> и <emphasis>b</emphasis>. В переменной <emphasis>a</emphasis> теперь ссылка на новый список, а в переменной <emphasis>b</emphasis> все та же ссылка на тот же список.</p>
   <p>Если <emphasis>a</emphasis> - переменная, хранящая ссылку на список, и присваивание <emphasis>b</emphasis> = <emphasis>a</emphasis> копирует только ссылку на тот же список, то можно ли скопировать сам список? Короткий ответ - да, можно. Но не все так просто. Ведь и сам список хранит не объекты, а ссылки на объекты. Должны ли копироваться эти ссылки или должны быть продублированы и сами объекты? Питон дает два ответа на этот вопрос: можно сделать и так, и эдак. Первый вариант копирования называется "поверхностным", второй - "глубоким" копированием. Глубокое копирование учитывает циклические ссылки. Классы, написанные программистом, могут определять методы, участвующие в копировании, тем самым "помогая" процессу копирования, для того чтобы не включать в копирование лишней информации.</p>
   <p>Манипуляции с неизменяемыми объектами осуществляются путем создания новых объектов. Например, если в строке надо заменить символ, исходная строка разбивается на две подстроки, и из них (плюс новый символ) создается новая строка. Если в переменной <emphasis>a</emphasis> ссылка на цело число, то в результате операции <emphasis>a</emphasis> += 1 в <emphasis>a</emphasis> окажется ссылка на новое число.</p>
  </section>
 </body>
</FictionBook>
